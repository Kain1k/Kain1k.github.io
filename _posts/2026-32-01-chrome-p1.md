---
title: "Chrome Exploitation Part 1: JavaScript and V8 Internals"
date: 2026-01-31 02:00:00 +0800
categories: [Browser Exploitation, Chrome]
tags: [Chrome Exploitation, Browser Exploitation]
---
To kick off the Browser Exploitation series, I want to start with Chrome Exploitation. The reason is that Chrome, more precisely, Chromium is the most widely used browser in the world, and the most popular operating system running it is Windows. Therefore, this series will focus on exploiting Chrome vulnerabilities in the Windows environment.

Actually, exploitation can be performed on any platform; we usually only need to make minor adjustments to the exploit code to adapt it. Personally, I work on both Windows and Linux platforms when developing and testing exploits.

If you have read my two previous articles, ``An Introduction to Browser Exploitation``, I introduced some of the most basic browser concepts. However, I did not go into much detail, leaving deeper analysis for each specific browser. Therefore, our goal now is to dig deeper into the concepts that appear in Chrome. Let's get started.

## JavaScript Engine Internal for V8
As we know, Chromium uses the V8 JavaScript engine. We will discuss engine-specific internals of Chromium's V8 JavaScript engine. Having a grasp of these concepts will make understanding (and writing!) exploits much more straightforward.

### Pointer Tagging & Pointer Compression
The first question we need to ask is: how does V8 distinguish between pointers, small integers, and double numbers?. So, V8 uses `pointer tagging` to differentiate pointers from JavaScript numbers. This "tag" is placed in the Least Significant Bit (LSB):
- 0 = **31 Bit** Integer (called an SMI - small integer)
- 1 = Pointer

```
[bits representation]
SMI:
XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX00000000000000000000000000000000
Pointer:
00000000000000000XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX01

[bytes representation]
SMI:
XXXXXXXX00000000|0
Pointer:
0000XXXXXXXXXXXX|1

uint64_t smi = (0x414243 << 32) | 0;
uint64_t pointer  = (uint64_t)(obj) | 1;
```
For floating-point numbers, V8 cannot distinguish them directly. Therefore, it creates a ``HeapNumber`` object on the heap and stores a pointer to it. And of course, V8 checks the object’s Map (hidden class) to determine that it is a double number. However, there are special cases, such as in the elements where double values can be stored inline and SMI do not require tagging. This will be discussed later.

Next is `pointer compression`. In fact, it is quite simple. `Pointer compression` (introduced in Chrome 80) is a memory optimization technique that reduces pointer sizes on 64-bit architectures from 8 bytes to 4 bytes. By instead of storing the full 64-bit address, V8 stores a 32-bit offset relative to a fixed base address. This helps reduce Chrome’s overall memory usage.

Pointer tagging and pointer compression are concepts specific to V8. In contrast, JavaScriptCore (JSC), which is used in Safari, takes a different and quite interesting approach known as `NaN boxing`. I will discuss this in an another blog.
### V8 Type Generalization

V8 implements the principle of "type generalization". As the property type changes, the type "widens" towards "more general". Importantly however, it never "shrinks" back towards "more specific"; once the type becomes generalized, it stays at that level or generalizes further.

The diagram below illustrates this, types move from "most specific" (SMI/double) up towards most general:

![](typegen.png)

Once we get to `Tagged Value`, we cannot get any more general. All we know is that:

1. We have some sort of "value"
2. We can tell whether it is a pointer or not by checking the LSB

A property type can get "more general" if a different type is stored in that property. When this happens, it triggers a transition.

We can use the `--trace-generalization` flag to log these as they happen:
```js
d8> let a = {a: 1.1}
d8> a.a = false; // Generalize from double to tagged value
[generalizing]a:d{Any}->t{Any} (+1 maps)
// d{Any} is double, t{Any} is tagged value

d8> a.a = 1.1; // Doesn't go back to double
```

### Object in V8
In V8, the simplest Object class is called a `HeapObject`:

```cpp
class HeapObject : public Object {
...
  // [map]: Contains a map which contains the object's reflective
  // information.
  DECL_GETTER(map, Map)
...
  // Layout description.
#define HEAP_OBJECT_FIELDS(V) \
  V(kMapOffset, kTaggedSize)  \
...
}
```

[/v8/src/objects/heap-object.h](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/heap-object.h;l=27;drc=ecaac3292fa0c216286bd3b42e069ea10bde51b5)

These `HeapObjects` are fairly simple; they define an object on the heap with a particular type:
```
HeapObject Structure:
00: [        Map*        ] (Tagged Ptr) -> Type information
```
All other Object classes then extend this class to add other values:
![](object.png)
### V8 JSObjects

Every JavaScript object in V8 is represented by a `JSObject`. 

Fundamentally, each object in V8 is a `HeapObject` as mentioned previously. However, we will need some additional features to build a full `JSObject`, as `HeapObject` only allows room for a `Map`:

```bash
HeapObject Structure:
00: [        Map*        ] (Tagged Ptr) -> Type information
```

The first step towards `JSObject` is `JSReceiver`. `JSReceiver` includes some more features we need, such as a Property Array/Hashmap and "Fast Properties", an inline list of properties.

We can see part of the definition below:

```cpp
// JSReceiver includes types on which properties can be defined, i.e.,
// JSObject and JSProxy.
class JSReceiver : public TorqueGeneratedJSReceiver<JSReceiver, HeapObject> {
...
  // 1) EmptyFixedArray/EmptyPropertyDictionary - This is the standard
  // placeholder.
  ...
  // 3) PropertyArray - This is similar to a FixedArray but stores
  // the hash code of the object in its length field. This is a fast
  // backing store.
  // 4) NameDictionary - This is the dictionary-mode backing store.
  DECL_ACCESSORS(raw_properties_or_hash, Object)
...
}
```

[/v8/src/objects/js-objects.h](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/js-objects.h;l=35;drc=416fae8653bd73ad78b09bba0d1ad40c4ecfb17b)

Now let's take a look at the structure of `JSReceiver` like we did with `HeapObject`:

```bash
np | cp  (np = normal pointer, cp = compressed pointer)
---+----
00 | 00: [        Map*        ] (TagPtr)
08 | 04: [ Property* or Hash  ] (TagPtr) -> Property FixedArray 
10 | 08: [  Fast Properties   ] (TagPtr[]) -> In-Object List of Properties
```

This is starting to look "feature-complete" but we still need a few final features, such as Elements.

The `JSObject` class in V8 handles this, among other things, and we can see the relevant snippet of its declaration below:

```cpp
// The JSObject describes real heap allocated JavaScript objects with
// properties.
// Note that the map of JSObject changes during execution to enable inline
// caching.
class JSObject : public TorqueGeneratedJSObject<JSObject, JSReceiver> {
...
  // [elements]: The elements (properties with names that are integers).
  // Elements can be in two general modes: fast and slow. Each mode
  // corresponds to a set of object representations of elements that
  // have something in common.
  DECL_ACCESSORS(elements, FixedArrayBase)
...
}
```

For completion's sake, we can also take a final look at our structure diagrams:

```bash
np | cp  (np = normal pointer, cp = compressed pointer)
---+----
00 | 00: [        Map*        ] (TagPtr)
08 | 04: [ Property* or Hash  ] (TagPtr)
10 | 08: [      Elements*     ] (TagPtr) -> Elements FixedArray or Sparse Array
18 | 0c: [  Fast Properties   ] (TagPtr[])
```
### V8 Map

The `Map` or `HiddenClasses` is one of the most important data structures in V8. Broadly speaking, these `Map`s are used by V8 to store a variety of type information such as:

- Object Type
- Property Keys and Value Indexes
- Prototype Pointer
- Allocation Size
- Number Of inline properties
- Type Transition links

While the property names are usually stored in the Map, the property values are stored with the object itself in one of several possible regions. The Map then provides the exact location of the property value in the respective region.

You can see a very detailed breakdown of the `Map` structure [here](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/map.h;l=106;drc=12bb6c21f2eedf33ca1540f35842af3995ec3c18).

```
 Normal*| Compress | Size | Info
 Offset |  Offset  |      |
--------+-----------------+---------------
 0      |  0       | ptr  | Meta Map (Tagged)
 8      |  4       |  1   | instance_size
                     ...
 0xc    |  8       |  2   | Instance Type
                     ...
 0xf    |  0xb     |  1   | (Bits 3..7) elements_kind
 0x10   |  0xc     |  4   | (Bit 21) is_dictionary_map
 0x18   |  0x10    | ptr  | Prototype (Tagged)
 0x28   |  0x18    | ptr  | instance_descriptors (Tagged)
 0x40   |  0x24    | ptr  | Transitions (Tagged)
 ...
 *64 bit non-compressed
```

More information on the structures can be found within V8’s source code and can be located within the [`/src/objects/map.h`](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/map.h;l=122-201) and [`/src/objects/descriptor-array.h`](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/descriptor-array.h) source files.
![](Map.png)

These maps are used to describe type information, which can be exceptionally dynamic in JavaScript. This dynamism is implemented via "Map Transitions", which govern how one kind of `Map` can be turned into another, or whether a new map is required:

In V8, you can watch these transitions happen "in real time" with the `--trace-maps` debug flag.

We can have an example about Map(Shape) Transition below.

![](Shapes1.png)
![](Shapes2.png)
![](Shapes3.png)
![](Shapes4.png)

You might wonder why V8 stores property offsets instead of direct value pointers. This is an important optimization. Maps (HiddenClasses) are relatively expensive in terms of memory, so storing full key–value dictionaries inside every JSObject would introduce significant overhead and slow property access. Otherside, what happens if a new object, such as `obj2` is created which shares the same properties of `obj1` such as x and y? Even though the values might be different the two objects actually share the same named properties in the same order, or as we would call it, the same `shape` or `map`. In that case it would be wasteful for us to store the same property name in two different locations.

This is what allows V8 to be fast, it’s optimized so that a Map is shared as much as possible between similarly shaped objects. Since the property names are repeated for all objects within the same shape and because they’re in the same order, we can have multiple objects point to one single `HiddenClass` in memory with the offset to the properties instead of pointers to values. This also allows for easier garbage collection since Map’s are allocations of a `HeapObject` just like the `JSObject`.

Let look at the important parts of the `HiddenClass`. The two most important parts of the `HiddenClass` that allow for the Map to have its “shape” is the `DescriptorArray` and the *third bit field*. If you look back into the Map structure above, you’ll notice that the third bit field stores the number of properties, and the descriptor array contains information about the named properties like the name itself, the position where the value is stored (offset), and the properties attributes.

For example, let’s say we create a new object such as `var obj {x: 1}`. The x property is going to be stored within the In-Object properties or Properties store of the JavaScript object. Since a new object is created, a new `HiddenClass` will also be created. Within that HiddenClass the descriptor array and the third bit field will be populated. The third bit field will set the `numberOfOwnDescriptors` to 1, since we only have one property, and then descriptor array will populate the key, details, and value portions of the array with details relating to property x. The value for that descriptor will be set to 0. Why 0? Well, the In-Object properties and the Properties store are just an array. So, by setting the value of the descriptor to 0, V8 knows that the keys value will be at offset 0 of that array for any object of the same shape.

A visual example can be seen below.

![](Map-DA.png)

Now, what would happen to the transition tree if we deleted a property? Well, in this case there is a nuance to V8 creating a new map each time a property deletion occurs. As we know, maps are relatively expensive when it comes to memory usage, so at a certain point the cost of inheriting and maintaining a transition tree will get larger and slower. In the case the last property of an object is deleted, the Map will just adjust the back pointer to go back to its previous map, instead of creating a new one. But what happens if we delete the middle property of an object? Well in that case V8 will give up on maintaining the transition tree whenever we are adding too many attributes or deleting non-last elements, and it’ll switch to a slower mode known as dictionary mode.

So, what is this dictionary mode? Well, now that we know how V8 uses HiddenClasses to track the shape of objects, we can now go back full circle and dive into further understanding how these Properties and Elements are actually stored and handled in V8.

### V8 Properties

We know that JavaScript objects have two fundamental kinds of properties: named properties and indexed elements.
![](Obj1.png)

#### 1. Named Properties
In general, there are two main different kinds of named properties: In-object and normal properties. Normal properties are further divided into two types: fast and slow properties.

**In-object** vs. **normal properties**: V8 supports so-called in-object properties which are stored directly on the object themselves. These are the fastest properties available in V8 as they are accessible without any indirection. The number of in-object properties is predetermined by the initial size of the object. If more properties get added than there is space in the object, they are stored in the properties store. The properties store adds one level of indirection but can be grown independently.
![](in-object-properties.png)
**Fast** vs. **slow properties**: The next important distinction is between fast and slow properties. Typically we define the properties stored in the linear properties store as "fast". Fast properties are simply accessed by index in the properties store. To get from the name of the property to the actual position in the properties store, we have to consult the descriptor array on the HiddenClass.

However, if many properties get added and deleted from an object, it can generate a lot of time and memory overhead to maintain the descriptor array and HiddenClasses. Hence, V8 also supports so-called slow properties. An object with slow properties has a self-contained dictionary as a properties store. All the properties meta information is no longer stored in the descriptor array on the HiddenClass but directly in the properties dictionary. Hence, properties can be added and removed without updating the HiddenClass. Since inline caches don’t work with dictionary properties, the latter, are typically slower than fast properties.
![](fast-vs-slow-properties.png)
Actually, slow properties have a slightly more complex structure than shown in the image above. The structure can be visualized below.

![](NamedDict.png)

When an object transitions from fast properties to slow properties for some reason, it no longer maintains inline properties and instead moves all properties into the properties backing store. In this state, the layout of properties depends on the hashmap algorithm and its seed, which may vary across executions. If such transitions are not properly rechecked during property access, they can lead to Type Confusion vulnerabilities.

For better understanding, you can read [Fast properties in V8](https://v8.dev/blog/fast-properties).
#### 2. Indexed Elements
Elements in JavaScript are quite similar to properties, with the major distinguishing feature being that Elements are accessed "by index" rather than "by key". In practice, if you access it "like an array", you are accessing an "Element" rather than a "Property".

This opens up some opportunities for optimization, but these all hinge on what "kind" of values are getting stored as Elements in any given object. V8 uses the concept of "Element Kind" to describe what it knows about the current Elements and to decide whether it can apply certain optimizations.

**Element Kind** is the term used to describe the overall type of all elements in a `JSObject`. The main idea is that if all elements are of a particular type, we can apply an optimization:

- If we know all elements are doubles, we can inline them
- If we know all elements are SMI, we can skip tag-checking

The different "types" of element kind are most easily seen and described by the Chromium source code:

```cpp
enum ElementsKind : uint8_t {
  // The "fast" kind for elements that only contain SMI values. Must be first
  // to make it possible to efficiently check maps for this kind.
  PACKED_SMI_ELEMENTS,
  HOLEY_SMI_ELEMENTS,

  // The "fast" kind for tagged values. Must be second to make it possible to
  // efficiently check maps for this and the PACKED_SMI_ELEMENTS kind
  // together at once.
  PACKED_ELEMENTS,
  HOLEY_ELEMENTS,

  // The "fast" kind for unwrapped, non-tagged double values.
  PACKED_DOUBLE_ELEMENTS,
  HOLEY_DOUBLE_ELEMENTS,

  ...
}
```

• [/v8/src/objects/elements-kind.h](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/elements-kind.h;l=31;drc=75a657f63c673633fa083c7321d82e5a1a3e0940)

When `elements_kind` is `(PACKED|HOLEY)_ELEMENTS`, we don't know anything at all about the elements' types. More precisely, we do not know anything beyond the fact that they will be tagged values. This is the most "general" of the element kinds.

```bash
d8> a=[1.1,1.1,1.1,false]
d8> %DebugPrint(a)
DebugPrint: 0xab14ed93989: [JSArray]
 - elements: 0x0ab14ed93929 <FixedArray[4]> [PACKED_ELEMENTS (COW)]

pwndbg> x/6xg 0x0ab14ed93929-1
0xab14ed93928:	0x00001afdbcb00801	0x0000000400000000
0xab14ed93938:	0x00001d673eaa3ec1	0x00001d673eaa3ed1
					0xab14ed93948:	0x00001d673eaa3ee1	0x00001afdbcb00709
```

An important observation here is that doubles will have to use `HeapNumbers` instead of being able to be inlined.

When `elements_kind` is `(PACKED|HOLEY)_DOUBLE_ELEMENTS`, we know that all elements are doubles. That means we no longer have to use `HeapNumber` to represent double-values. Because the engine knows that every element will be a double, it can inline raw "un-boxed" doubles and skip the machinery associated with pointer-tagging:

```bash
d8> a=[1.1,1.1,1.1,1.1]
d8> %DebugPrint(a)
DebugPrint: 0xab14ed93fe1: [JSArray]
 - elements: 0x0ab14ed93fb1 <FixedDoubleArray[4]> [PACKED_DOUBLE_ELEMENTS]

pwndbg> x/6xg 0x0ab14ed93fb1-1
0xab14ed93fb0:	0x00001afdbcb01459	0x0000000400000000
0xab14ed93fc0:	0x3ff199999999999a	0x3ff199999999999a
0xab14ed93fd0:	0x3ff199999999999a	0x3ff199999999999a
```

So how does V8 use these element types for an array? Are they set for the array or for each element? The answer is that the element type is set for the array. The important thing we have to remember is that element kinds have a “transition” that only go in one direction. We can view this transition tree from a “top down” approach as such.
![](elements-transition.png)

Next, we also need to understand the first major distinction that V8 has when it tracks element backing stores when an index is deleted, or empty. And those are "Packed" and "Holey".

"Packed" and "Holey" elements simply refer to whether or not there is "space" between elements.

- Packed: No "empty space" / Dense
- Holey: Some empty space / Sparse

Empty elements are filled with a special value called `the_hole` which is simply a placeholder. That value in ``HOLEY_DOUBLE_ELEMENTS``: `0xfff7fffffff7ffff`.

For example, let’s take the following two arrays:

```js
const packed_array = [1,2,3,5.5,'x'];
// Elements Kind: PACKED_ELEMENTS
const holey_array = [1,2,,5,'x'];
// Elements Kind: HOLEY_ELEMENTS
```

As you can see, the holey_array has “holes” in it, since we forgot to add the 3 to the index and just left it blank or undefined. The reason that V8 makes this distinction is because operations on packed arrays can be optimized more aggressively than operations on holey arrays. If you want to learn more about that, then I suggest you watch Mathias Bynens’s talk [V8 internals for JavaScript Developers](https://www.youtube.com/watch?v=m9cTaYI95Zc) which details this very well.

V8 also implements the previously mentioned elements kind transitions on both PACKED and HOLEY arrays, which forms a “lattice”. A simple visualization of those transitions from the V8 blog can be seen below.

![](meo.png)

Eventually, if the elements are "Holey", it may be more efficient to switch to a hashmap or dictionary rather than continuing to use `the_hole`.

For example, imagine the following scenario:

```js
let a = [1.1,1.1,1.1]

a[10000] = 1.1;
```

Clearly, having thousands of indices with `the_hole` is wasteful. Instead, V8 switches to `DICTIONARY_ELEMENTS` in such situations. The below debug output shows this switch occurring as we try to insert 1.1 at index 10000:
```bash
d8> a=[1.1,1.1,1.1]
d8> %DebugPrint(a)
DebugPrint: 0x349c6ca8bab9: [JSArray]
 - elements: 0x349c6ca8ba91 <FixedDoubleArray[3]> [PACKED_DOUBLE_ELEMENTS]
d8> a[10000] = 1.1;
DebugPrint: 0x349c6ca8bab9: [JSArray]
 - elements: 0x349c6ca8bc09 <NumberDictionary[28]> [DICTIONARY_ELEMENTS]

pwndbg> x/16xg 0x349c6ca8bc09-1
0x349c6ca8bc08: 0x00001bbf2e9016d9  0x0000001c00000000
0x349c6ca8bc18: 0x0000000400000000  0x0000000000000000
0x349c6ca8bc28: 0x0000000800000000  0x00004e2000000000
0x349c6ca8bc38: 0x0000000100000000  0x0000349c6ca8bbe9
0x349c6ca8bc48: 0x000000c000000000  0x00001bbf2e9004d1
0x349c6ca8bc58: 0x00001bbf2e9004d1  0x00001bbf2e9004d1
0x349c6ca8bc68: 0x0000271000000000  0x00001cef3a4df621
0x349c6ca8bc78: 0x000000c000000000  0x00001bbf2e9004d1
```

So on that, we may have total 7 elements kinds.

### V8 JSArrays

Just like `JSObject` expands on `JSReceiver`, `JSArray` expands on `JSObject` by introducing a length property:

```jsx
// The JSArray describes JavaScript Arrays
//  Such an array can be in one of two modes:
//    - fast, backing storage is a FixedArray and length <= elements.length();
//       Please note: push and pop can be used to grow and shrink the array.
//    - slow, backing storage is a HashTable with numbers as keys.
class JSArray : public TorqueGeneratedJSArray<JSArray, JSObject> {
  // [length]: The length property.
    DECL_ACCESSORS(length, Object)
    ...
}
```

- [/v8/src/objects/js-array.h](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/js-array.h;l=24;drc=0697a1b063e7660591aa7b992308c80d53e87dfb)
- [Also defined in /v8/src/objects/js-array.tq](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/js-array.tq;l=27;drc=624030e975cb4384f877b65070b4e650a6acb1ef)

The associated structure diagram:

```
np | cp  (np = normal pointer, cp = compressed pointer)
---+----
00 | 00: [        Map*        ] (TagPtr)
08 | 04: [ Property* or Hash  ] (TagPtr)
10 | 08: [      Elements*     ] (TagPtr) -> Elements FixedArray or Hash Map
18 | 0c: [       Length       ] (SMI) -> Current length of the JSArray
20 | 10: [  Fast Properties   ] (TagPtr[])
                  ...
```

### V8 Typed Arrays

JavaScript includes support for "native style" arrays via Typed Arrays. These are used to store arbitrary binary data in a memory buffer:

```jsx
d8> let a = new ArrayBuffer(0x100);
d8> let b = new Uint8Array(a);
d8> b[0] = 0x41;
```

`Uint8Array` is a `JSTypedArray`, which wraps `JSArrayBuffer`. There are also versions for most of the commonly used binary data-types such as `Uint16`, `Uint32`, `Float64`, etc.

### V8 JSArrayBuffer

Looking at the definitions below, we can see that a `JSArrayBuffer` is just an Object that is augmented with a few special fields:

```cpp
class JSArrayBuffer: public TorqueGeneratedJSArrayBuffer<JSArrayBuffer, JSObject> { ... }
```

• [/v8/src/objects/js-array-buffer.h](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/js-array-buffer.h;l=22;drc=28105df3e305d0c54e25d54a0fbb901dd1479954)

And the corresponding "Torque" definition (a custom language for parts of V8):

```jsx
@generateCppClass
extern class JSArrayBuffer extends JSObject {
  byte_length: uintptr;
  backing_store: ExternalPointer;
  extension: RawPtr;
  bit_field: JSArrayBufferFlags;
}
```

• [/v8/src/objects/js-array-buffer.tq](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/js-array-buffer.tq;l=14;drc=28105df3e305d0c54e25d54a0fbb901dd1479954)

We can also take a look at the structure diagram:

```jsx
np | cp  (np = normal pointer, cp = compressed pointer)
---+----
00 | 00: [        Map*        ] (TagPtr)
08 | 04: [ Property* or Hash  ] (TagPtr)
10 | 08: [      Elements*     ] (TagPtr)
18 | 0c: [     Byte Length    ] (size_t) -> Size of buffer in bytes
20 | 14: [   Backing Store*   ] (void*) -> Allocated memory (not tagged!)
28 | 1c: [     Extension*     ] (void*) -> Used by GC
30 | 24: [     Bit Field      ] (uint32) -> Flags 
                  ...
```

For our purposes, `JSArrayBuffer` is a great corruption target because with some creativity, we can turn them into a stable way of performing arbitrary read/write operations.

### V8 JSArrayBufferView

The `JSArrayBufferView` is the next step towards `JSTypedArray`. In JavaScript, "Views" are used as a way of actually interacting with data in an ArrayBuffer. You can think of an ArrayBuffer as the actual "chunk" of memory, while a "View" is your tool for manipulating it.

```cpp
class JSArrayBufferView
    : public TorqueGeneratedJSArrayBufferView<JSArrayBufferView, JSObject> {
```

• [/v8/src/objects/js-array-buffer.h](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/js-array-buffer.h;l=228;drc=28105df3e305d0c54e25d54a0fbb901dd1479954)

```cpp
@abstract
@generateCppClass
extern class JSArrayBufferView extends JSObject {
  buffer: JSArrayBuffer; // NOTE this is a pointer TO an array buffer
  byte_offset: uintptr;
  byte_length: uintptr;
}
```

• [/v8/src/objects/js-array-buffer.tq](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/js-array-buffer.tq;l=38;drc=28105df3e305d0c54e25d54a0fbb901dd1479954)

Below, we can see some of the additions `JSArrayBufferView` makes to a standard `JSObject`:

```cpp
np | cp  (np = normal pointer, cp = compressed pointer)
---+----
00 | 00: [        Map*        ] (TagPtr)
08 | 04: [ Property* or Hash  ] (TagPtr)
10 | 08: [      Elements*     ] (TagPtr)
18 | 0c: [    Array Buffer*   ] (TagPtr) -> Pointer to array buffer
20 | 10: [     Byte Offset    ] (size_t) -> Start of view
28 | 18: [     Byte Length    ] (size_t) -> Size of view
                  ...
```

### V8 JSTypedArray

Finally, we are ready to take a look at `JSTypedArray`. As before, we can see the definition below. Note that `JSTypedArray` inherits from `JSArrayBufferView` rather than directly from `ArrayBuffer`.

```cpp
class JSTypedArray
    : public TorqueGeneratedJSTypedArray<JSTypedArray, JSArrayBufferView> { ... }
```

- [/v8/src/objects/js-array-buffer.h](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/js-array-buffer.h;l=249;drc=28105df3e305d0c54e25d54a0fbb901dd1479954)

```cpp
V8 Torque
@generateCppClass
extern class JSTypedArray extends JSArrayBufferView {
  length: uintptr;
  external_pointer: ExternalPointer;
  base_pointer: ByteArray|Smi;
}
```

- [/v8/src/objects/js-array-buffer.tq](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/js-array-buffer.tq;l=45;drc=28105df3e305d0c54e25d54a0fbb901dd1479954)

Finally, we have our structure diagram:

```cpp
np | cp  (np = normal pointer, cp = compressed pointer)
---+----
00 | 00: [        Map*        ] (TagPtr)
08 | 04: [ Property* or Hash  ] (TagPtr)
10 | 08: [      Elements*     ] (TagPtr)
18 | 0c: [    Array Buffer*   ] (TagPtr) -> Pointer to array buffer
20 | 10: [     Byte Offset    ] (size_t) -> Start of view
28 | 18: [     Byte Length    ] (size_t) -> Size of view
30 | 20: [   Element Length   ] (size_t) -> Byte Length divided by Typed Array element size
                  ...
```

### Strings

Strings are less commonly used for exploitation, but we'll briefly cover them here.

```cpp
// The Name abstract class captures anything that can be used as a property
// name, i.e., strings and symbols.  All names store a hash value.
class Name : public TorqueGeneratedName<Name, PrimitiveHeapObject> { ... }

// The String abstract class captures JavaScript string values:
//
// Ecma-262:
//  4.3.16 String Value
//    A string value is a member of the type String and is a finite
//    ordered sequence of zero or more 16-bit unsigned integer values.
//
// All string values have a length field.
class String : public TorqueGeneratedString<String, Name> { ... }
```

- [/v8/src/objects/string.h](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/string.h;l=97;drc=5a2c53f9482e19d150303cd36d7ba04418e6cade)
- [/v8/src/objects/name.h](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/name.h;l=23;drc=5a2c53f9482e19d150303cd36d7ba04418e6cade)

```cpp
@generateCppClass
extern class Name extends PrimitiveHeapObject {
  raw_hash_field: NameHash;
}

@generateCppClass
@reserveBitsInInstanceType(6)
extern class String extends Name {
  const length: int32;
}
```

- [/v8/src/objects/string.tq](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/string.tq;l=10;drc=5a2c53f9482e19d150303cd36d7ba04418e6cade)
- [/v8/src/objects/name.tq](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/objects/name.tq;l=7;drc=5a2c53f9482e19d150303cd36d7ba04418e6cade)

This forms an abstract base class for various string representations:

```cpp
np | cp  (np = normal pointer, cp = compressed pointer)
---+----
00 | 00: [        Map*        ] (TagPtr)
08 | 04: [        Hash        ] (uint32)
0c | 08: [       Length       ] (int32)
                  ...
```

#### Strings: Representation Types

The "type" of the string (i.e. which subclass of `String` it is) can be found in the `Map` structure, in bits of the `instance_type` field

```cpp
@reserveBitsInInstanceType(6)
extern class String extends Name {
  macro StringInstanceType(): StringInstanceType {
    return %RawDownCast<StringInstanceType>(
        Convert<uint16>(this.map.instance_type));
  }
}

bitfield struct StringInstanceType extends uint16 {
  representation: StringRepresentationTag: 3 bit;
  is_one_byte: bool: 1 bit;
  is_uncached: bool: 1 bit;
  is_not_internalized: bool: 1 bit;
}

extern enum StringRepresentationTag extends uint32 {
  kSeqStringTag,
  kConsStringTag,
  kExternalStringTag,
  kSlicedStringTag,
  kThinStringTag
}
```

- [/v8/src/objects/string.tq](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/string.tq;l=19;drc=5a2c53f9482e19d150303cd36d7ba04418e6cade)

Note that strings can have either 8-bit or 16-bit characters in memory, as indicated by `is_one_byte`. This optimizes for the common case of strings with only 8-bit code points (e.g. ASCII).

`SeqString` is the simplest representation, with the variably-sized character buffer inlined after the `String` fields:

```cpp
@abstract
extern class SeqString extends String {}

extern class SeqOneByteString extends SeqString {
  const chars[length]: char8;
}

extern class SeqTwoByteString extends SeqString {
  const chars[length]: char16;
}
```

- [/v8/src/objects/string.tq](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/string.tq;l=108;drc=5a2c53f9482e19d150303cd36d7ba04418e6cade)

```cpp
np | cp  (np = normal pointer, cp = compressed pointer)
---+----
00 | 00: [        Map*        ] (TagPtr)
08 | 04: [        Hash        ] (uint32)
0c | 08: [       Length       ] (int32)
10 | 0c: [       Buffer       ] (char8[] / char16[]) variably-sized array

```

The other types are:

```cpp
// concatenation of two strings
// e.g. cons = str1 + str2
extern class ConsString extends String {
  first: String;
  second: String;
}

// substring of existing string
// e.g. sliced = str.slice(i)
extern class SlicedString extends String {
  parent: String;
  offset: Smi;
}

// alias / reference to other string
extern class ThinString extends String {
  actual: String;
}

// string backed by memory not on the v8 heap
// not used internally
extern class ExternalString extends String {
  resource: ExternalPointer;
  resource_data: ExternalPointer;
}
```

- [/v8/src/objects/string.tq](https://source.chromium.org/chromium/chromium/src/+/master:v8/src/objects/string.tq;l=37;drc=5a2c53f9482e19d150303cd36d7ba04418e6cade)

## V8 Torque

Torque is a language developed by Google that is "TypeScript-like". It is higher-level for easier development, but still has access to internal C++ functions. You can find this code by looking for `.tq` files in the Chromium source tree.

It is most commonly used to implement builtin functions defined by the JS standard. For example, here is the torque implementation of `Number.prototype.toString`:

```cpp
// https://tc39.github.io/ecma262/#sec-number.prototype.tostring
transitioning javascript builtin NumberPrototypeToString(
    js-implicit context: NativeContext, receiver: JSAny)(
    ...arguments): String {
  // 1. Let x be ? thisNumberValue(this value).
  const x = ThisNumberValue(receiver, 'Number.prototype.toString');

  // 2. If radix is not present, let radixNumber be 10.
  // 3. Else if radix is undefined, let radixNumber be 10.
  // 4. Else, let radixNumber be ? ToInteger(radix).
  const radix: JSAny = arguments[0];
  const radixNumber: Number = radix == Undefined ? 10 : ToInteger_Inline(radix);

  // 5. If radixNumber < 2 or radixNumber > 36, throw a RangeError exception.
  if (radixNumber < 2 || radixNumber > 36) {
    ThrowRangeError(MessageTemplate::kToRadixFormatRange);
  }

  // 6. If radixNumber = 10, return ! ToString(x).
  if (radixNumber == 10) {
    return NumberToString(x);
  }

  // 7. Return the String representation of this Number
  //    value using the radix specified by radixNumber.

  if (TaggedIsSmi(x)) {
    return IntToString(
        Convert<int32>(x), Unsigned(Convert<int32>(radixNumber)));
  }

  if (x == -0) {
    return ZeroStringConstant();
  } else if (::NumberIsNaN(x)) {
    return NaNStringConstant();
  } else if (x == V8_INFINITY) {
    return InfinityStringConstant();
  } else if (x == MINUS_V8_INFINITY) {
    return MinusInfinityStringConstant();
  }

  return runtime::DoubleToStringWithRadix(x, radixNumber);
}

```

- [/v8/src/builtins/number.tq](https://source.chromium.org/chromium/chromium/src/+/main:v8/src/builtins/number.tq;l=180;drc=8dcc3bf28a4c05a735c1963dd1dd0284ea7e2ec5)

For vulnerability research purposes, Torque is not particularly interesting but it's good to be aware of its existence.

You can find detailed information here: https://v8.dev/docs/torque

## Reference
[Exploiting Logic Bugs in JavaScript JIT Engines ](https://phrack.org/issues/70/9)

[Chrome Browser Exploitation, Part 1: Introduction to V8 and JavaScript Internals](https://jhalon.github.io/chrome-browser-exploitation-1/)